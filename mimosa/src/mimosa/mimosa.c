#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h> // update err function 
#include <string.h>

#include "mimosa.h"

//MarFS Includes

#include "tagging/tagging.h"
#include "config/config.h"
#include "datastream/datastream.h"

#define STR_BUF_SIZE 256
#define MDAL_PREFIX MDAL_subspaces/full-access-subspace/

// MarFS Globals (initialize with mimosa_init())
marfs_config* config = NULL;
marfs_position* root_ns_pos = NULL;
marfs_position* dest_pos = NULL;
marfs_position* thread_curr_pos = NULL;

// This function initializes the global config and sets up initial positions.
// @param config: reference of global config struct to be initialized. This config is extern and declared in mimosa.h.
// @param mutex: IDK
// @param dest_arg: path to the destination MarFS user path for this pwalk iteration. Received from the command line arguments of mimosa.py.
// @return none
void mimosa_main_init(marfs_config** config, pthread_mutex_t* mutex, char* dest_arg)
{
	// populate global config struct
	*config = config_init(getenv("MARFS_CONFIG_PATH"), mutex);
	if (*config == NULL)
		err("Failed to Initialize MarFS context\n"); 
	
	// establish position based on config
	root_ns_pos = (marfs_position*) calloc(1, sizeof(marfs_position));
	if (config_establishposition(root_ns_pos, *config) == -1)
		err("Failed to establish position of root namespace\n");
	
	// set position of destination
	dest_pos = dup_pos(root_ns_pos);

	if (config_traverse(*config, dest_pos, &dest_arg, 1) < 0)
		err("Failed to traverse to destination position\n");
	
	// set current position for threads
	thread_curr_pos = dup_pos(dest_pos);

	if (config_fortifyposition(dest_pos) == -1)
		err("Failed to create MDAL_CTXT for dest_pos\n");
	
	mimosa_create_file(dest_pos, "create_file_test.user9", mimosa_generate_ftag()); 
	mimosa_create_dir(dest_pos, "create_dir_test1");	

	exit(0);
}

/*
void mimosa_thread_init()
{

}
*/

// This function contains the entire process of mapping a file/directory from POSIX to MarFS.
// @param user_path: POSIX path of the file/dir generated by pwalk. The destination MarFS path will be determined from this path.
// @param stat_struct: stat struct of the file user_path. This is passed as an argument to reduce I/O load. 
// @return 0 on success, -1 on failure
int mimosa_convert(char* user_path, struct stat* stat_struct)
{
	char* ref_str_buf = (char *) calloc(1, STR_BUF_SIZE);
	sprintf(ref_str_buf, "MDAL_subspaces/mimosa-test-space/%s", user_path); 

	if (S_ISDIR(stat_struct->st_mode))
	{
		// update current position
		// - will likely need to traverse from root in case going back up
		//
	}
	if (S_ISREG(stat_struct->st_mode))
	{
		// mimosa_create_file( pos, ref_str_buf, user_path, mimosa_generate_ftag() );
	}

	return 0;
}

// INTERNAL FUNCTIONS

// This function creates a MarFS file in both the reference and user tree. 
// @param pos: MarFS position to create the file relative to
// @param ref_path: reference tree path of the file. Will be generated by datastream_genrpath().
// @param user_path: MarFS user tree path for the file, in which the user will be able to find it.
// @param ftag: ftag struct containing metadata for the reference tree file
// @return -1 if the file already exists, or 0 on success
int mimosa_create_file(marfs_position* pos, char* user_path, FTAG ftag_struct)
{
	// If the file exists in the user tree, skip it. If not, execute the steps below. If any steps have already been
	// executed before a failure, re-execution will do nothing, and mapping will resume after the point of failure. 
	if (pos->ns->prepo->metascheme.mdal->access(pos->ctxt, user_path, F_OK, 0) == 0)
	{
		printf("file %s exists, skipping\n", user_path);
		return -1;
	}
	
	char* ref_path = datastream_genrpath(&ftag_struct, pos->ns->prepo->metascheme.reftable, pos->ns->prepo->metascheme.mdal, pos->ctxt);
	MDAL_FHANDLE fhandle = pos->ns->prepo->metascheme.mdal->openref(pos->ctxt, ref_path, O_WRONLY | O_CREAT, S_IRWXU);
        if (fhandle == NULL)
                printf("openref Failed to get file handle: %s\n", strerror(errno));
		
        char* xattr_str_buf = (char *) calloc(1, STR_BUF_SIZE);
        ftag_tostr(&ftag_struct, xattr_str_buf, STR_BUF_SIZE); // will not work properly until more fields defined
        
	if (pos->ns->prepo->metascheme.mdal->fsetxattr(fhandle, 1, ref_path, xattr_str_buf, sizeof(FTAG), XATTR_CREATE) == -1)
                printf("Failed to set xattr: %s\n", strerror(errno));

        if (pos->ns->prepo->metascheme.mdal->linkref(dest_pos->ctxt, 0, ref_path, user_path) == -1)
                printf("linkref: failed to link refernce and user file %s\n", strerror(errno));

	return 0;
}

// Create a MarFS directory at a specific position
// @param pos: MarFS position to create the directory relative to
// @param user_path: path to create the directory at relative to the position
// @return -1 on error, 0 on success
int mimosa_create_dir(marfs_position* pos, char* user_path)
{
	if (pos->ns->prepo->metascheme.mdal->mkdir(pos->ctxt, user_path, S_IRWXU) == -1)
	{
		printf("mdal->mkdir: error creating directory %s: %s\n", user_path, strerror(errno));
		return -1;
	}
	
	return 0;
}


FTAG mimosa_generate_ftag()
{
	FTAG ftag_struct = { 0 };
        ftag_struct.state = FTAG_INIT;
        ftag_struct.ctag = "mimosa-created";

	return ftag_struct;
}


void marfs_test_create()
{
	FTAG ftag_struct = { 0 };
        ftag_struct.state = FTAG_INIT;
	ftag_struct.ctag = "mimosa-created";
	
	int tgt_buf_size = 256;
	char* xattr_str_buf = (char *) calloc(1, tgt_buf_size);
	ftag_tostr(&ftag_struct, xattr_str_buf, tgt_buf_size); // will not work properly until more fields defined
	
	MDAL_FHANDLE fhandle = dest_pos->ns->prepo->metascheme.mdal->openref(dest_pos->ctxt, "teststrxattr2", O_WRONLY | O_CREAT, S_IRWXU);	
	if (fhandle == NULL) 
		printf("openref Failed to get file handle: %s\n", strerror(errno));

	if (dest_pos->ns->prepo->metascheme.mdal->fsetxattr(fhandle, 1, "test-xattr", xattr_str_buf, sizeof(FTAG), XATTR_CREATE) == -1)
		printf("Failed to set xattr: %s\n", strerror(errno));
	
	if (dest_pos->ns->prepo->metascheme.mdal->linkref(dest_pos->ctxt, 0, "teststrxattr2", "mimosa.strxattr2") == -1)
		printf("linkref: failed to link refernce and user file %s\n", strerror(errno));

	exit(0);
}

marfs_position* dup_pos(marfs_position* src)
{
	marfs_position* dest_pos = malloc(sizeof(marfs_position));
        memcpy(dest_pos, root_ns_pos, sizeof(marfs_position));
	return dest_pos;
}

void err(char* err_msg)
{
	printf("ERROR: %s", err_msg);
}

